## 2026-02-22 — Phase 0: Types & Skeleton

Implemented:
- Created `src/watcher/types.ts` with all four type definitions (WatchOptions, WatchHandle, WatchBatch, WatchError) mirroring the spec exactly
- Created `src/watcher/index.ts` barrel exporting functions and types
- Created `src/watcher/watch-session.ts` stub with registry Map and function signatures (throw "Not implemented")
- Created empty `src/watcher/__tests__/` directory for upcoming tests

Files changed:
- src/watcher/types.ts (new)
- src/watcher/index.ts (new)
- src/watcher/watch-session.ts (new)

Verified: typecheck passes, all 421 tests pass.

## 2026-02-22 — Phase 0: Core Read Loop

Implemented:
- Implemented `watchSession()` in `src/watcher/watch-session.ts`: on init reads file size, sets `byteOffset`, registers `fs.watch` listener, returns `WatchHandle`
- On fs.watch change: reads new bytes via `Bun.file().slice().text()`, splits on `\n`, passes lines to `parseLine()`, collects non-null results
- Flushes immediately (no debounce) — calls `onMessages` with `WatchBatch` containing parsed messages and `byteRange`
- Added internal `WatcherState` type to track FSWatcher alongside handle
- Implemented minimal `stopWatching()` (closes fs.watch, removes from registry, sets stopped=true) and `stopAll()` for teardown

Files changed:
- src/watcher/watch-session.ts (rewritten from stub)

Verified: typecheck passes, all 421 tests pass.

## 2026-02-22 — Phase 0: Tracer Bullet Test

Implemented:
- Created `src/watcher/__tests__/helpers.ts` with temp file utilities: `createTempJsonl()` (creates empty .jsonl in temp dir with cleanup), `appendLines()` (appends newline-terminated lines)
- Created `src/watcher/__tests__/watch-session.test.ts` with two tests:
  - "delivers parsed messages with correct byteRange after file append" — appends two JSONL lines to empty file, asserts correct message kinds, lineIndex assignment, byteRange coverage, and handle state
  - "only tails new content appended after watcher starts" — pre-populates file, starts watcher, appends new line, verifies only new content is delivered and byteRange starts at initial file size
- Reuses parser test helpers (`makeUserPrompt`, `makeAssistantRecord`, `makeTextBlock`, `toLine`) for fixture data

Files changed:
- src/watcher/__tests__/helpers.ts (new)
- src/watcher/__tests__/watch-session.test.ts (new)

Verified: typecheck passes, all 423 tests pass (421 existing + 2 new).

## 2026-02-22 — Phase 1: Partial Line Buffering

Implemented:
- Added `lineBuffer: string` field to `WatcherState` interface, initialized to `""` on watcher creation
- Changed read-loop to prepend `lineBuffer` to new text before splitting on `\n`
- After splitting, `segments.pop()` captures any trailing incomplete segment as the new `lineBuffer` — only complete lines (before a `\n`) are passed to `parseLine`
- Refactored watcher creation to build `WatcherState` object before `fs.watch`, assigning `fsWatcher` after creation (avoids chicken-and-egg with closure needing state reference)
- Added `appendRaw()` helper to test utilities for writing text without auto-appending `\n`

Tests added:
- "buffers partial line and delivers only after completing newline" — writes a JSON line in two halves, asserts no callback after first half, one message after second half
- "lineBuffer is empty after a complete-line write" — writes a full line with `\n`, asserts message delivered and handle state correct

Files changed:
- src/watcher/watch-session.ts (modified — added lineBuffer to state, updated read loop)
- src/watcher/__tests__/helpers.ts (modified — added appendRaw)
- src/watcher/__tests__/watch-session.test.ts (modified — added 2 tests)

Verified: typecheck passes, all 425 tests pass (423 existing + 2 new).

## 2026-02-22 — Phase 1: Two-Phase Debounce

Implemented:
- Added `scheduleBatchFlush()` with trailing-edge timer (`debounceMs`, default 100ms) that resets on each new write, coalescing rapid bursts into single deliveries
- Added max-wait ceiling timer (`maxWaitMs`, default 500ms) that fires once and does not reset, bounding worst-case latency during sustained writes
- Added `flush()` function: clears both timers, delivers `WatchBatch` with correct `byteRange` (from `batchStartOffset` to current `byteOffset`), resets `pendingMessages` and `batchStartOffset`
- Replaced immediate flush in read loop with message accumulation in `state.pendingMessages` + `scheduleBatchFlush()` call
- Updated `stopWatching()` and `stopAll()` to cancel timers and perform final flush of pending messages
- Added `processing` guard flag with re-check loop to prevent concurrent async `fs.watch` callbacks from causing data loss during rapid writes

Tests added:
- "coalesces rapid writes into few batches with default debounce" — writes 10 lines in tight loop, asserts 1–2 batches totaling 10 messages
- "max-wait ceiling ensures periodic flushes during sustained writes" — writes 1 line every 50ms for 2s with maxWaitMs: 500, asserts at least 4 flushes totaling 40 messages

Files changed:
- src/watcher/watch-session.ts (modified — added debounce state, scheduleBatchFlush, flush, processing guard)
- src/watcher/__tests__/watch-session.test.ts (modified — added 2 tests)

Gotchas:
- Concurrent async `fs.watch` callbacks: when multiple writes occur in a tight loop, `fs.watch` can fire multiple callbacks that run concurrently (each yields at `await .text()`). Without a processing guard + re-check loop, callbacks can read overlapping byte ranges or miss data written during in-flight reads. Solution: `state.processing` boolean serializes callbacks, and a `while` loop re-checks file size after each read.

Verified: typecheck passes, all 427 tests pass (425 existing + 2 new).

## 2026-02-22 — Phase 1: Watcher Registry & Duplicate Prevention

Implemented:
- Added duplicate prevention guard at the top of `watchSession()`: if `sessionId` already exists in the module-level `registry` Map, return the existing handle immediately without creating a new watcher
- The `Map<string, WatcherState>` registry (keyed by sessionId) was already in place from the core read loop implementation; this task adds the dedup check that makes it effective

Tests added:
- "returns existing handle when watchSession is called twice with same sessionId" — calls `watchSession` twice with same `sessionId`, asserts identical handle reference (`toBe`), appends a line and verifies only the first callback fires (second callback throws if invoked)

Files changed:
- src/watcher/watch-session.ts (modified — added early-return guard for duplicate sessionId)
- src/watcher/__tests__/watch-session.test.ts (modified — added 1 test)

Verified: typecheck passes, all 428 tests pass (427 existing + 1 new).

## 2026-02-22 — Phase 1: Stop & Teardown

Implemented:
- Refactored `stopAll()` to delegate to `stopWatching()` instead of duplicating teardown logic — collects handles from registry first, then iterates to avoid modifying the map mid-iteration
- `stopWatching()` was already correct from Phase 0: closes fs.watch, cancels timers via `flush()`, final-flushes pending messages, sets `handle.stopped = true`, removes from registry
- `stopWatching()` on already-stopped handle is a no-op (early return guard)

Tests added:
- "final-flushes pending messages on stopWatching before debounce fires" — uses 5s debounce, appends a line, waits for fs.watch processing, calls `stopWatching` before debounce fires, asserts exactly one batch with the pending message
- "no callbacks fire after stopWatching even when file is appended to" — delivers one message, stops watcher, appends another line, asserts callback count stays at 1
- "stopAll stops all watchers and prevents further callbacks" — starts 3 watchers on separate temp files, delivers one message each, calls `stopAll`, verifies all handles stopped, appends more lines, asserts no further callbacks

Files changed:
- src/watcher/watch-session.ts (modified — refactored stopAll to delegate to stopWatching)
- src/watcher/__tests__/watch-session.test.ts (modified — added 3 tests)

Verified: typecheck passes, all 431 tests pass (428 existing + 3 new).
