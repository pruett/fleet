## 2026-02-23 — Phase 0: Transport type definitions

Created `src/transport/types.ts` with all core type definitions:
- `ConnectedClient` — internal per-connection tracking (clientId, ws, sessionId, connectedAt)
- `ClientRegistry` — dual-indexed maps (clients by ID, sessions inverse index)
- `TransportOptions` — dependency-injected watcher functions + session resolver
- `Transport` — public interface (handleOpen/Message/Close, broadcastLifecycleEvent, shutdown, counts)
- `LifecycleEvent` — discriminated union of SessionStarted | SessionStopped | SessionError

Files changed:
- `src/transport/types.ts` (new)

Notes:
- `ServerWebSocket` must be explicitly imported from `"bun"` (not globally available despite `"types": ["bun"]` in tsconfig)
- `resolveSessionPath` typed as async (`Promise<string | null>`) since `resolveSessionFile` in the API module is async
- Used `ServerWebSocket<unknown>` to match Bun's server-side WebSocket type

## 2026-02-23 — Phase 0: createTransport() factory stub

Created `src/transport/create-transport.ts` with `createTransport()` factory function:
- Accepts `TransportOptions` (dependency injection for watchSession, stopWatching, resolveSessionPath)
- Returns `Transport` interface with all methods as no-ops (stubs for later phases)
- Added `src/transport/index.ts` barrel export following project convention

Files changed:
- `src/transport/create-transport.ts` (new)
- `src/transport/index.ts` (new)

Notes:
- Followed the `createApp(deps)` factory pattern from `src/api/create-app.ts`
- Options parameter prefixed with `_` since it's unused in the stub phase
- Barrel index re-exports both runtime (`createTransport`) and all types

## 2026-02-23 — Phase 0: handleOpen connection lifecycle

Implemented `handleOpen` in `createTransport`:
- Initializes `ClientRegistry` internal state (`clients` map, `sessions` inverse map)
- Adds `wsToClientId` reverse lookup map (`ServerWebSocket` → `clientId`) for O(1) client lookup in handleMessage/handleClose
- `handleOpen` generates UUID v4 via `crypto.randomUUID()`, creates `ConnectedClient`, stores in both maps
- `getClientCount` now returns `clients.size` (was hardcoded 0)

Files changed:
- `src/transport/create-transport.ts` (modified)

Notes:
- `crypto.randomUUID()` is globally available in Bun — no import needed
- `sessions` map initialized but unused until subscribe is implemented
- `_options` parameter still unused — will be consumed when subscribe/relay logic is added

## 2026-02-23 — Phase 0: handleClose connection lifecycle

Implemented `handleClose` in `createTransport`:
- Looks up `clientId` via `wsToClientId` reverse map (O(1))
- Removes client from `clients` map and `wsToClientId` map
- Early return (no-op) if ws is unknown/already removed — defensive against double-close

Files changed:
- `src/transport/create-transport.ts` (modified)

Notes:
- Subscription cleanup (removing from `sessions` map, stopping watchers) is deferred to Phase 1
- Idempotency (handleClose called twice) is naturally handled by the early return guard

## 2026-02-23 — Phase 0: handleMessage dispatch

Implemented `handleMessage` in `createTransport`:
- Rejects binary frames (`typeof data !== "string"`) by closing with status 1003
- Parses JSON text frames; sends `{ type: "error", code: "INVALID_MESSAGE" }` on parse failure
- Dispatches on `message.type` via switch: `"subscribe"` and `"unsubscribe"` cases (stubs for now), default sends `INVALID_MESSAGE` error with the unknown type
- Replaced the no-op `handleMessage: () => {}` in the return object with the real function

Files changed:
- `src/transport/create-transport.ts` (modified)

Notes:
- Subscribe/unsubscribe case bodies are TODO stubs — those are separate plan tasks
- Binary detection uses `typeof data !== "string"` which matches Bun's WebSocket callback signature (`string | Buffer`)
- Error frames follow the spec's `{ type: "error", code, message }` shape

## 2026-02-23 — Phase 0: Subscribe handler

Implemented `handleSubscribe` in `createTransport`:
- Validates `sessionId` format using UUID v4 regex; sends `INVALID_MESSAGE` error if invalid
- Calls `resolveSessionPath(sessionId)` (async); sends `UNKNOWN_SESSION` error if null
- Sets `client.sessionId` and adds `clientId` to `sessions` inverse map
- For first subscriber to a session, calls `options.watchSession()` with `onMessages` wired to `relayBatch` stub, stores `WatchHandle` in `watchers` map
- Subsequent subscribers to the same session are no-ops (watcher already running)
- Added `watchers` map (`sessionId → WatchHandle`) to internal state
- `relayBatch` is defined as a no-op stub — full implementation is the next plan task
- Removed `_` prefix from `options` parameter (now consumed by subscribe handler)

Files changed:
- `src/transport/create-transport.ts` (modified)

Notes:
- `handleSubscribe` is async (calls `resolveSessionPath`); called fire-and-forget from synchronous `handleMessage` dispatch
- `WatchOptions` does not have a `byteOffset` field — the watcher starts from current file size. Client-side dedup by `lineIndex` handles any overlap (per spec)
- Implicit unsubscribe on re-subscribe is deferred to Phase 1 (unsubscribe handler)
- UUID v4 regex: `/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i`

## 2026-02-23 — Phase 0: relayBatch

Implemented `relayBatch` in `createTransport`:
- Looks up subscriber set from `sessions` map by `batch.sessionId`
- Returns early if no subscribers (race window guard — watcher may fire after last subscriber leaves)
- Serializes the outbound frame **once** via `JSON.stringify` with `{ type: "messages", sessionId, messages, byteRange }`
- Iterates subscriber set, looks up each `ConnectedClient`, sends the pre-serialized frame
- Skips clients missing from the `clients` map (defensive guard)

Files changed:
- `src/transport/create-transport.ts` (modified)

Notes:
- Frame is serialized once and reused across all subscribers — avoids redundant `JSON.stringify` for multi-client fan-out
- Uses `batch.sessionId` (not the `_sessionId` parameter) for consistency with the batch's own identity
- `try/catch` around `ws.send` for broken pipe handling is deferred to Phase 2 (Send Failures task)
- Bun's `ServerWebSocket.send()` doesn't throw on closed sockets in typical usage, but the Phase 2 guard will add resilience
