## 2026-02-23 — Phase 0: Transport type definitions

Created `src/transport/types.ts` with all core type definitions:
- `ConnectedClient` — internal per-connection tracking (clientId, ws, sessionId, connectedAt)
- `ClientRegistry` — dual-indexed maps (clients by ID, sessions inverse index)
- `TransportOptions` — dependency-injected watcher functions + session resolver
- `Transport` — public interface (handleOpen/Message/Close, broadcastLifecycleEvent, shutdown, counts)
- `LifecycleEvent` — discriminated union of SessionStarted | SessionStopped | SessionError

Files changed:
- `src/transport/types.ts` (new)

Notes:
- `ServerWebSocket` must be explicitly imported from `"bun"` (not globally available despite `"types": ["bun"]` in tsconfig)
- `resolveSessionPath` typed as async (`Promise<string | null>`) since `resolveSessionFile` in the API module is async
- Used `ServerWebSocket<unknown>` to match Bun's server-side WebSocket type

## 2026-02-23 — Phase 0: createTransport() factory stub

Created `src/transport/create-transport.ts` with `createTransport()` factory function:
- Accepts `TransportOptions` (dependency injection for watchSession, stopWatching, resolveSessionPath)
- Returns `Transport` interface with all methods as no-ops (stubs for later phases)
- Added `src/transport/index.ts` barrel export following project convention

Files changed:
- `src/transport/create-transport.ts` (new)
- `src/transport/index.ts` (new)

Notes:
- Followed the `createApp(deps)` factory pattern from `src/api/create-app.ts`
- Options parameter prefixed with `_` since it's unused in the stub phase
- Barrel index re-exports both runtime (`createTransport`) and all types

## 2026-02-23 — Phase 0: handleOpen connection lifecycle

Implemented `handleOpen` in `createTransport`:
- Initializes `ClientRegistry` internal state (`clients` map, `sessions` inverse map)
- Adds `wsToClientId` reverse lookup map (`ServerWebSocket` → `clientId`) for O(1) client lookup in handleMessage/handleClose
- `handleOpen` generates UUID v4 via `crypto.randomUUID()`, creates `ConnectedClient`, stores in both maps
- `getClientCount` now returns `clients.size` (was hardcoded 0)

Files changed:
- `src/transport/create-transport.ts` (modified)

Notes:
- `crypto.randomUUID()` is globally available in Bun — no import needed
- `sessions` map initialized but unused until subscribe is implemented
- `_options` parameter still unused — will be consumed when subscribe/relay logic is added

## 2026-02-23 — Phase 0: handleClose connection lifecycle

Implemented `handleClose` in `createTransport`:
- Looks up `clientId` via `wsToClientId` reverse map (O(1))
- Removes client from `clients` map and `wsToClientId` map
- Early return (no-op) if ws is unknown/already removed — defensive against double-close

Files changed:
- `src/transport/create-transport.ts` (modified)

Notes:
- Subscription cleanup (removing from `sessions` map, stopping watchers) is deferred to Phase 1
- Idempotency (handleClose called twice) is naturally handled by the early return guard

## 2026-02-23 — Phase 0: handleMessage dispatch

Implemented `handleMessage` in `createTransport`:
- Rejects binary frames (`typeof data !== "string"`) by closing with status 1003
- Parses JSON text frames; sends `{ type: "error", code: "INVALID_MESSAGE" }` on parse failure
- Dispatches on `message.type` via switch: `"subscribe"` and `"unsubscribe"` cases (stubs for now), default sends `INVALID_MESSAGE` error with the unknown type
- Replaced the no-op `handleMessage: () => {}` in the return object with the real function

Files changed:
- `src/transport/create-transport.ts` (modified)

Notes:
- Subscribe/unsubscribe case bodies are TODO stubs — those are separate plan tasks
- Binary detection uses `typeof data !== "string"` which matches Bun's WebSocket callback signature (`string | Buffer`)
- Error frames follow the spec's `{ type: "error", code, message }` shape

## 2026-02-23 — Phase 0: Subscribe handler

Implemented `handleSubscribe` in `createTransport`:
- Validates `sessionId` format using UUID v4 regex; sends `INVALID_MESSAGE` error if invalid
- Calls `resolveSessionPath(sessionId)` (async); sends `UNKNOWN_SESSION` error if null
- Sets `client.sessionId` and adds `clientId` to `sessions` inverse map
- For first subscriber to a session, calls `options.watchSession()` with `onMessages` wired to `relayBatch` stub, stores `WatchHandle` in `watchers` map
- Subsequent subscribers to the same session are no-ops (watcher already running)
- Added `watchers` map (`sessionId → WatchHandle`) to internal state
- `relayBatch` is defined as a no-op stub — full implementation is the next plan task
- Removed `_` prefix from `options` parameter (now consumed by subscribe handler)

Files changed:
- `src/transport/create-transport.ts` (modified)

Notes:
- `handleSubscribe` is async (calls `resolveSessionPath`); called fire-and-forget from synchronous `handleMessage` dispatch
- `WatchOptions` does not have a `byteOffset` field — the watcher starts from current file size. Client-side dedup by `lineIndex` handles any overlap (per spec)
- Implicit unsubscribe on re-subscribe is deferred to Phase 1 (unsubscribe handler)
- UUID v4 regex: `/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i`

## 2026-02-23 — Phase 0: relayBatch

Implemented `relayBatch` in `createTransport`:
- Looks up subscriber set from `sessions` map by `batch.sessionId`
- Returns early if no subscribers (race window guard — watcher may fire after last subscriber leaves)
- Serializes the outbound frame **once** via `JSON.stringify` with `{ type: "messages", sessionId, messages, byteRange }`
- Iterates subscriber set, looks up each `ConnectedClient`, sends the pre-serialized frame
- Skips clients missing from the `clients` map (defensive guard)

Files changed:
- `src/transport/create-transport.ts` (modified)

Notes:
- Frame is serialized once and reused across all subscribers — avoids redundant `JSON.stringify` for multi-client fan-out
- Uses `batch.sessionId` (not the `_sessionId` parameter) for consistency with the batch's own identity
- `try/catch` around `ws.send` for broken pipe handling is deferred to Phase 2 (Send Failures task)
- Bun's `ServerWebSocket.send()` doesn't throw on closed sockets in typical usage, but the Phase 2 guard will add resilience

## 2026-02-23 — Phase 0: Transport unit tests

Created test infrastructure and Phase 0 tracer bullet test for `createTransport`:

- `src/transport/__tests__/helpers.ts` — mock WebSocket factory (`createMockWebSocket`), mock `TransportOptions` builder (`createMockTransportOptions`) that captures `watchSession` calls and allows manual triggering of watcher callbacks
- `src/transport/__tests__/create-transport.test.ts` — 9 tests covering the full Phase 0 surface:
  1. **Tracer bullet**: open → subscribe → watcher fires batch → client receives `{ type: "messages", sessionId, messages, byteRange }` frame with correct shape
  2. Client count tracking across open/close
  3. Binary frame rejection (close 1003)
  4. Invalid JSON error response
  5. Unknown message type error response
  6. Invalid sessionId format error response
  7. Unknown session (resolveSessionPath returns null) error response
  8. Multi-client fan-out: two subscribers, one watcher, both receive the batch
  9. handleClose idempotency (double-close is a no-op)

Files changed:
- `src/transport/__tests__/helpers.ts` (new)
- `src/transport/__tests__/create-transport.test.ts` (new)

Notes:
- `ParsedMessage` schema requires `isMeta` on user-prompt, `contentBlock` (singular) on assistant-block, and snake_case `input_tokens`/`output_tokens` on usage — matching Zod schemas exactly
- Mock WebSocket `closed` state exposed via getter (not plain property) to avoid destructuring capturing stale null value
- All 483 tests pass (9 new + 474 existing), TypeScript clean

## 2026-02-23 — Phase 1: Unsubscribe handler

Implemented `handleUnsubscribe` in `createTransport`:
- Looks up client via `wsToClientId` reverse map, early returns if client not found or not subscribed
- Removes `clientId` from the `sessions` inverse map subscriber set
- When subscriber set empties (last subscriber leaves): deletes session entry from `sessions` map, calls `options.stopWatching(handle)`, removes watcher from `watchers` map
- Clears `client.sessionId = null`
- Wired into `case "unsubscribe":` dispatch in `handleMessage` (replaced TODO stub)

Files changed:
- `src/transport/create-transport.ts` (modified)
- `plans/real-time-transport.md` (updated checkbox)

Notes:
- `handleUnsubscribe` is synchronous (no async needed — no IO calls)
- Guard ordering: check client exists, check sessionId is non-null, then proceed with cleanup
- The function is also reusable for `handleClose` wiring (next task) and implicit unsubscribe on re-subscribe
- All 483 tests pass, TypeScript clean, Biome clean

## 2026-02-23 — Phase 1: Wire unsubscribe into handleClose

Wired `handleUnsubscribe(ws)` call into `handleClose`, executed before removing the client from the registry maps. This ensures that when a client disconnects, its session subscription is cleaned up — removing it from the `sessions` inverse map and stopping the watcher when the last subscriber for a session leaves.

Files changed:
- `src/transport/create-transport.ts` (modified — added `handleUnsubscribe(ws)` call in `handleClose`)
- `src/transport/__tests__/create-transport.test.ts` (modified — added 2 new tests)

Tests added:
1. handleClose triggers unsubscribe and stops watcher when last subscriber disconnects
2. handleClose does not stop watcher when other subscribers remain (multi-client scenario)

Notes:
- Ordering is critical: `handleUnsubscribe` must run before `clients.delete`/`wsToClientId.delete` since it needs both maps to resolve the client
- `handleUnsubscribe` already handles the no-subscription case (early return if `client.sessionId === null`), so no extra guard needed
- All 485 tests pass (2 new + 483 existing), TypeScript clean, Biome clean

## 2026-02-23 — Phase 1: Implicit unsubscribe on re-subscribe

Implemented implicit unsubscribe in `handleSubscribe` — when a client already subscribed to session A sends a subscribe for session B, the old subscription is cleaned up first (watcher stopped if last subscriber, client removed from old session's inverse map).

Key design decision: the implicit unsubscribe happens **after** validating the new sessionId format and resolving the new session path. This prevents accidentally unsubscribing a client from a working session if the new subscription fails validation or resolution.

Files changed:
- `src/transport/create-transport.ts` (modified — added implicit unsubscribe guard in `handleSubscribe`)
- `src/transport/__tests__/create-transport.test.ts` (modified — added 2 new tests)
- `src/transport/__tests__/helpers.ts` (modified — added `VALID_SESSION_ID_2` constant)
- `plans/real-time-transport.md` (updated checkboxes)

Tests added:
1. Re-subscribe to different session unsubscribes from old session and stops its watcher
2. Re-subscribe does not unsubscribe if new session fails to resolve

Notes:
- The guard is `client.sessionId !== null && client.sessionId !== sessionId` — subscribing to the same session is a separate concern (Phase 3 duplicate idempotency)
- All 487 tests pass (2 new + 485 existing), TypeScript clean

## 2026-02-23 — Phase 1: Lifecycle Broadcast

Implemented `broadcastLifecycleEvent` in `createTransport`:
- Serializes the `LifecycleEvent` once via `JSON.stringify`
- Iterates all connected clients (regardless of subscription state) and sends the pre-serialized frame
- Replaced the no-op stub `broadcastLifecycleEvent: () => {}` with the real implementation

Also checked off Multi-Client Fan-Out plan items — these were already implemented and tested in Phase 0 (test at line 191 of create-transport.test.ts verifies: one watcher for two subscribers, both receive the batch, reference equality confirms serialize-once).

Files changed:
- `src/transport/create-transport.ts` (modified — replaced broadcastLifecycleEvent no-op)
- `src/transport/__tests__/create-transport.test.ts` (modified — added 2 new tests, imported LifecycleEvent type)
- `plans/real-time-transport.md` (updated checkboxes)

Tests added:
1. Broadcast reaches all connected clients (subscribed, unsubscribed, different sessions) — verifies all 3 receive the event and reference equality of sent frames
2. Broadcast to zero clients is a no-op (no throw)

Notes:
- Implementation is 4 lines — serialize once, iterate clients.values(), send to each
- All 489 tests pass (2 new + 487 existing), TypeScript clean, Biome clean

## 2026-02-23 — Phase 1: Shutdown

Implemented `shutdown` in `createTransport`:
- Stops all watchers by iterating the `watchers` map and calling `options.stopWatching(handle)` for each
- Closes all WebSocket connections with code 1001 ("Going Away") and reason "Server shutting down"
- Clears all internal state maps: `clients`, `sessions`, `watchers`, `wsToClientId`

Files changed:
- `src/transport/create-transport.ts` (modified — replaced shutdown no-op with real implementation)
- `src/transport/__tests__/create-transport.test.ts` (modified — added 2 new tests in "Phase 1 shutdown" describe block)

Tests added:
1. Shutdown with 3 clients (2 subscribed to different sessions, 1 unsubscribed): verifies all watchers stopped, all clients closed with 1001, internal state cleared
2. Shutdown with no clients or watchers is a no-op (does not throw)

Notes:
- Watchers are stopped before closing WebSocket connections — prevents race where a watcher callback fires after client close but before cleanup
- Ordering: stop watchers → close connections → clear maps
- All 491 tests pass (2 new + 489 existing), TypeScript clean, Biome clean

## 2026-02-23 — Phase 1: Utility Methods

Implemented `getSessionSubscriberCount` in `createTransport`:
- Looks up the subscriber set from the `sessions` inverse map for the given `sessionId`
- Returns `set.size` if found, `0` if no subscribers or unknown session
- `getClientCount` was already correctly implemented as `clients.size` — no changes needed

Files changed:
- `src/transport/create-transport.ts` (modified — replaced hardcoded `() => 0` with real lookup)
- `src/transport/__tests__/create-transport.test.ts` (modified — added 3 new tests in "Phase 1 utility methods" describe block)
- `plans/real-time-transport.md` (updated checkboxes)

Tests added:
1. `getClientCount` reflects connected clients across open/close
2. `getSessionSubscriberCount` returns 0 for unknown session
3. `getSessionSubscriberCount` tracks subscribers accurately through subscribe/unsubscribe/disconnect lifecycle

Notes:
- All 494 tests pass (3 new + 491 existing), TypeScript clean, Biome clean

## 2026-02-23 — Phase 2: Handle watchSession throwing

Implemented error handling for `watchSession` throwing in `handleSubscribe`:
- Wrapped `options.watchSession()` call in try/catch
- On failure: sends `{ type: "error", code: "WATCH_FAILED" }` to the client
- Reverts subscription state: removes clientId from `sessions` set, deletes session entry, resets `client.sessionId = null`
- Also checked off Phase 2 Client Message Validation items (binary rejection, invalid JSON, unknown type, sessionId validation) — all were already implemented in Phase 0
- Checked off Phase 3 items already done: test helpers, handleClose idempotency

Files changed:
- `src/transport/create-transport.ts` (modified — wrapped watchSession in try/catch with state revert)
- `src/transport/__tests__/create-transport.test.ts` (modified — added 1 new test in "Phase 2 subscribe error cases" describe block)
- `plans/real-time-transport.md` (updated checkboxes)

Tests added:
1. watchSession throw sends WATCH_FAILED error, reverts state, and allows successful re-subscribe

Notes:
- The catch block can unconditionally delete the session entry (no size check needed) because the watcher is only started for the first subscriber (`subscriberSet.size === 1`), so after removing the one subscriber the set is always empty
- TypeScript correctly narrowed `subscriberSet.size` to literal `1` from the outer guard, making a `=== 0` check a type error — simplified by removing the redundant check
- All 495 tests pass (1 new + 494 existing), TypeScript clean, Biome clean

## 2026-02-23 — Phase 2: Send Failure Resilience

Wrapped `ws.send` in try/catch in both `relayBatch` and `broadcastLifecycleEvent` to handle broken pipe / closed socket errors gracefully. A failing send to one client no longer prevents delivery to remaining clients.

Also added `createBrokenMockWebSocket` test helper — creates a mock whose `send()` always throws, simulating a broken pipe.

Files changed:
- `src/transport/create-transport.ts` (modified — try/catch around ws.send in relayBatch and broadcastLifecycleEvent)
- `src/transport/__tests__/helpers.ts` (modified — added `createBrokenMockWebSocket` factory)
- `src/transport/__tests__/create-transport.test.ts` (modified — added 2 new tests in "Phase 2 send failures" describe block)
- `plans/real-time-transport.md` (updated checkboxes)

Tests added:
1. relayBatch skips broken client and delivers to remaining healthy clients
2. broadcastLifecycleEvent skips broken client and delivers to remaining healthy clients

Notes:
- The catch blocks are intentionally empty — there's no useful recovery action for a broken pipe during fan-out
- All 497 tests pass (2 new + 495 existing), TypeScript clean, Biome clean

## 2026-02-23 — Phase 3: Duplicate Subscribe Idempotency

Implemented duplicate subscribe idempotency in `handleSubscribe` — when a client sends a subscribe for the session it's already subscribed to, the request is a no-op. No duplicate watcher is started, no double-add to the subscriber set, and no error is sent.

Added an early return guard after sessionId format validation: `if (client.sessionId === sessionId) return;`. This check runs before `resolveSessionPath` so it avoids unnecessary async work.

Files changed:
- `src/transport/create-transport.ts` (modified — added early return for same-session subscribe)
- `src/transport/__tests__/create-transport.test.ts` (modified — added 1 new test in "Phase 3 duplicate subscribe idempotency" describe block)
- `plans/real-time-transport.md` (updated checkboxes)

Tests added:
1. Duplicate subscribe to same session is a no-op: no second watcher, subscriber count stays at 1, no error sent, relay still delivers

Notes:
- The guard placement is intentional — it runs after format validation but before `resolveSessionPath` to avoid wasted async resolution
- Renumbered inline comments (steps 3-7 → 3-8) to account for the new step 2
- All 498 tests pass (1 new + 497 existing), TypeScript clean, Biome clean

## 2026-02-23 — Phase 3: Add transport to AppDependencies

Added `transport: Transport` to the `AppDependencies` interface in `src/api/types.ts`, making the transport a required dependency of the application. Updated the test helper `createMockDeps` to include a no-op mock `Transport` so all existing API tests continue to pass.

Files changed:
- `src/api/types.ts` (modified — added `import type { Transport }` and `transport: Transport` field)
- `src/api/__tests__/helpers.ts` (modified — added `import type { Transport }`, created `mockTransport` no-op object in `createMockDeps`)
- `plans/real-time-transport.md` (updated checkbox)

Notes:
- Transport is a required (not optional) field — every `AppDependencies` consumer must provide it
- The no-op mock transport in `createMockDeps` follows the same pattern as the other mock dependencies (stubs returning empty/default values)
- `createApp` does not use `deps.transport` yet — it's available for future API routes that need transport state (e.g., subscriber counts, lifecycle broadcasting from controller hooks)
- All 498 tests pass (0 new + 498 existing), TypeScript clean, Biome clean

## 2026-02-23 — Phase 3: resolveSessionPath adapter

Added `createResolveSessionPath` adapter function to `src/api/resolve.ts`. This factory partially applies `basePaths` to `resolveSessionFile`, producing a function matching the `TransportOptions.resolveSessionPath` signature: `(sessionId: string) => Promise<string | null>`.

Files changed:
- `src/api/resolve.ts` (modified — added `createResolveSessionPath` factory function)
- `src/api/index.ts` (modified — added `createResolveSessionPath` to barrel export)
- `src/api/__tests__/resolve.test.ts` (modified — added 2 new tests for the adapter)
- `plans/real-time-transport.md` (updated checkbox)

Tests added:
1. Adapter resolves existing session files with pre-applied basePaths
2. Adapter returns null for unknown sessions

Notes:
- The adapter is a one-liner closure: `(sessionId) => resolveSessionFile(basePaths, sessionId)`
- Bridges the gap between the two-argument `resolveSessionFile(basePaths, sessionId)` and the single-argument `resolveSessionPath(sessionId)` expected by `TransportOptions`
- Will be consumed when wiring `createTransport` into the server entry point (next task)
- All 500 tests pass (2 new + 498 existing), TypeScript clean

## 2026-02-23 — Phase 3: Wire createTransport into Bun server WebSocket upgrade path

Created `src/api/create-server.ts` with a `createServer(deps)` function that composes the Hono HTTP app with WebSocket transport handling into a Bun-compatible server configuration.

The function returns `{ fetch, websocket }` — an object that can be spread into `Bun.serve({ port, ...createServer(deps) })`:
- `fetch` routes requests to `/ws` through Bun's `server.upgrade()` for WebSocket handshake; all other requests fall through to the Hono app
- `websocket.open/message/close` delegate directly to `transport.handleOpen/handleMessage/handleClose`

Also exported `ServerOptions` interface and `createServer` from the `src/api/index.ts` barrel.

Files changed:
- `src/api/create-server.ts` (new — `createServer` function + `ServerOptions` interface)
- `src/api/index.ts` (modified — added `createServer` and `ServerOptions` exports)
- `src/api/__tests__/create-server.test.ts` (new — 11 tests)
- `plans/real-time-transport.md` (updated checkbox)

Tests added:
1. Returns object with fetch and websocket properties
2. Upgrades requests to /ws path (calls server.upgrade, returns undefined)
3. Returns 400 when upgrade fails
4. Does not upgrade requests to other paths (falls through to Hono)
5. Does not upgrade /ws/ with trailing slash
6. Does not upgrade /ws/sub-path
7. open delegates to transport.handleOpen
8. message delegates to transport.handleMessage
9. close delegates to transport.handleClose
10. Non-WebSocket requests pass through to Hono app (verifies /api/projects returns data)
11. 404 for unknown API routes

Notes:
- Used `Server<undefined>` (not `Server<unknown>`) because Bun's `Server.upgrade()` requires a `data` argument when the generic param is not `undefined`
- The `ServerOptions` interface is structurally compatible with `Bun.serve()` — callers spread it alongside `port`, `hostname`, etc.
- WebSocket upgrade path is exactly `/ws` (no trailing slash, no sub-paths) per spec: "The server upgrades a single well-known path (e.g., `/ws`) to WebSocket"
- All 511 tests pass (11 new + 500 existing), TypeScript clean, Biome clean
- This completes all plan items — the entire real-time transport implementation plan is done
