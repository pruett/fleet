## 2026-02-22 — Phase 0: Types & Skeleton

Implemented:
- Created `src/watcher/types.ts` with all four type definitions (WatchOptions, WatchHandle, WatchBatch, WatchError) mirroring the spec exactly
- Created `src/watcher/index.ts` barrel exporting functions and types
- Created `src/watcher/watch-session.ts` stub with registry Map and function signatures (throw "Not implemented")
- Created empty `src/watcher/__tests__/` directory for upcoming tests

Files changed:
- src/watcher/types.ts (new)
- src/watcher/index.ts (new)
- src/watcher/watch-session.ts (new)

Verified: typecheck passes, all 421 tests pass.

## 2026-02-22 — Phase 0: Core Read Loop

Implemented:
- Implemented `watchSession()` in `src/watcher/watch-session.ts`: on init reads file size, sets `byteOffset`, registers `fs.watch` listener, returns `WatchHandle`
- On fs.watch change: reads new bytes via `Bun.file().slice().text()`, splits on `\n`, passes lines to `parseLine()`, collects non-null results
- Flushes immediately (no debounce) — calls `onMessages` with `WatchBatch` containing parsed messages and `byteRange`
- Added internal `WatcherState` type to track FSWatcher alongside handle
- Implemented minimal `stopWatching()` (closes fs.watch, removes from registry, sets stopped=true) and `stopAll()` for teardown

Files changed:
- src/watcher/watch-session.ts (rewritten from stub)

Verified: typecheck passes, all 421 tests pass.

## 2026-02-22 — Phase 0: Tracer Bullet Test

Implemented:
- Created `src/watcher/__tests__/helpers.ts` with temp file utilities: `createTempJsonl()` (creates empty .jsonl in temp dir with cleanup), `appendLines()` (appends newline-terminated lines)
- Created `src/watcher/__tests__/watch-session.test.ts` with two tests:
  - "delivers parsed messages with correct byteRange after file append" — appends two JSONL lines to empty file, asserts correct message kinds, lineIndex assignment, byteRange coverage, and handle state
  - "only tails new content appended after watcher starts" — pre-populates file, starts watcher, appends new line, verifies only new content is delivered and byteRange starts at initial file size
- Reuses parser test helpers (`makeUserPrompt`, `makeAssistantRecord`, `makeTextBlock`, `toLine`) for fixture data

Files changed:
- src/watcher/__tests__/helpers.ts (new)
- src/watcher/__tests__/watch-session.test.ts (new)

Verified: typecheck passes, all 423 tests pass (421 existing + 2 new).

## 2026-02-22 — Phase 1: Partial Line Buffering

Implemented:
- Added `lineBuffer: string` field to `WatcherState` interface, initialized to `""` on watcher creation
- Changed read-loop to prepend `lineBuffer` to new text before splitting on `\n`
- After splitting, `segments.pop()` captures any trailing incomplete segment as the new `lineBuffer` — only complete lines (before a `\n`) are passed to `parseLine`
- Refactored watcher creation to build `WatcherState` object before `fs.watch`, assigning `fsWatcher` after creation (avoids chicken-and-egg with closure needing state reference)
- Added `appendRaw()` helper to test utilities for writing text without auto-appending `\n`

Tests added:
- "buffers partial line and delivers only after completing newline" — writes a JSON line in two halves, asserts no callback after first half, one message after second half
- "lineBuffer is empty after a complete-line write" — writes a full line with `\n`, asserts message delivered and handle state correct

Files changed:
- src/watcher/watch-session.ts (modified — added lineBuffer to state, updated read loop)
- src/watcher/__tests__/helpers.ts (modified — added appendRaw)
- src/watcher/__tests__/watch-session.test.ts (modified — added 2 tests)

Verified: typecheck passes, all 425 tests pass (423 existing + 2 new).

## 2026-02-22 — Phase 1: Two-Phase Debounce

Implemented:
- Added `scheduleBatchFlush()` with trailing-edge timer (`debounceMs`, default 100ms) that resets on each new write, coalescing rapid bursts into single deliveries
- Added max-wait ceiling timer (`maxWaitMs`, default 500ms) that fires once and does not reset, bounding worst-case latency during sustained writes
- Added `flush()` function: clears both timers, delivers `WatchBatch` with correct `byteRange` (from `batchStartOffset` to current `byteOffset`), resets `pendingMessages` and `batchStartOffset`
- Replaced immediate flush in read loop with message accumulation in `state.pendingMessages` + `scheduleBatchFlush()` call
- Updated `stopWatching()` and `stopAll()` to cancel timers and perform final flush of pending messages
- Added `processing` guard flag with re-check loop to prevent concurrent async `fs.watch` callbacks from causing data loss during rapid writes

Tests added:
- "coalesces rapid writes into few batches with default debounce" — writes 10 lines in tight loop, asserts 1–2 batches totaling 10 messages
- "max-wait ceiling ensures periodic flushes during sustained writes" — writes 1 line every 50ms for 2s with maxWaitMs: 500, asserts at least 4 flushes totaling 40 messages

Files changed:
- src/watcher/watch-session.ts (modified — added debounce state, scheduleBatchFlush, flush, processing guard)
- src/watcher/__tests__/watch-session.test.ts (modified — added 2 tests)

Gotchas:
- Concurrent async `fs.watch` callbacks: when multiple writes occur in a tight loop, `fs.watch` can fire multiple callbacks that run concurrently (each yields at `await .text()`). Without a processing guard + re-check loop, callbacks can read overlapping byte ranges or miss data written during in-flight reads. Solution: `state.processing` boolean serializes callbacks, and a `while` loop re-checks file size after each read.

Verified: typecheck passes, all 427 tests pass (425 existing + 2 new).

## 2026-02-22 — Phase 1: Watcher Registry & Duplicate Prevention

Implemented:
- Added duplicate prevention guard at the top of `watchSession()`: if `sessionId` already exists in the module-level `registry` Map, return the existing handle immediately without creating a new watcher
- The `Map<string, WatcherState>` registry (keyed by sessionId) was already in place from the core read loop implementation; this task adds the dedup check that makes it effective

Tests added:
- "returns existing handle when watchSession is called twice with same sessionId" — calls `watchSession` twice with same `sessionId`, asserts identical handle reference (`toBe`), appends a line and verifies only the first callback fires (second callback throws if invoked)

Files changed:
- src/watcher/watch-session.ts (modified — added early-return guard for duplicate sessionId)
- src/watcher/__tests__/watch-session.test.ts (modified — added 1 test)

Verified: typecheck passes, all 428 tests pass (427 existing + 1 new).

## 2026-02-22 — Phase 1: Stop & Teardown

Implemented:
- Refactored `stopAll()` to delegate to `stopWatching()` instead of duplicating teardown logic — collects handles from registry first, then iterates to avoid modifying the map mid-iteration
- `stopWatching()` was already correct from Phase 0: closes fs.watch, cancels timers via `flush()`, final-flushes pending messages, sets `handle.stopped = true`, removes from registry
- `stopWatching()` on already-stopped handle is a no-op (early return guard)

Tests added:
- "final-flushes pending messages on stopWatching before debounce fires" — uses 5s debounce, appends a line, waits for fs.watch processing, calls `stopWatching` before debounce fires, asserts exactly one batch with the pending message
- "no callbacks fire after stopWatching even when file is appended to" — delivers one message, stops watcher, appends another line, asserts callback count stays at 1
- "stopAll stops all watchers and prevents further callbacks" — starts 3 watchers on separate temp files, delivers one message each, calls `stopAll`, verifies all handles stopped, appends more lines, asserts no further callbacks

Files changed:
- src/watcher/watch-session.ts (modified — refactored stopAll to delegate to stopWatching)
- src/watcher/__tests__/watch-session.test.ts (modified — added 3 tests)

Verified: typecheck passes, all 431 tests pass (428 existing + 3 new).

## 2026-02-22 — Phase 2: File Truncation Recovery

Implemented:
- Added truncation detection in the read loop: when `currentSize < handle.byteOffset`, reset `byteOffset = 0`, `lineIndex = 0`, clear `lineBuffer`, discard `pendingMessages`, reset `batchStartOffset`, then `continue` to re-read from beginning
- Changed the existing `currentSize <= handle.byteOffset` break condition to two separate checks: truncation recovery (`<`) and no-new-data break (`===`)
- Added `truncateFile()` helper to test utilities

Tests added:
- "recovers from file truncation by resetting and re-reading from beginning" — pre-populates file to >500 bytes, starts watcher, truncates to 0, writes new content, asserts watcher delivers new content with `lineIndex` reset to 0

Files changed:
- src/watcher/watch-session.ts (modified — added truncation detection and state reset)
- src/watcher/__tests__/helpers.ts (modified — added truncateFile)
- src/watcher/__tests__/watch-session.test.ts (modified — added 1 test)

Verified: typecheck passes, all 432 tests pass (431 existing + 1 new).

## 2026-02-22 — Phase 2: Error Resilience

Implemented:
- Wrapped `Bun.file().slice().text()` in try/catch — on failure emits `WatchError` with `code: "READ_ERROR"`, breaks out of re-check loop but continues watching on next fs.watch event (byteOffset not advanced, so data is re-read on recovery)
- Wrapped `parseLine` call in try/catch — on unexpected throw emits `WatchError` with `code: "PARSE_ERROR"`, skips line, advances `lineIndex`, continues processing remaining lines
- Added `fsWatcher.on("error", ...)` handler — emits `WatchError` with `code: "WATCH_ERROR"` and auto-stops the watcher via `stopWatching()`
- Added explicit blank-line skip (`line === ""`) before `parseLine` — aligns with spec pseudocode and prevents blank lines from entering the try/catch path
- Exported `_registry` (prefixed with underscore) for test access to internal FSWatcher

Tests added:
- "emits READ_ERROR on read failure and continues watching on next event" — uses `chmod 0o200` (write-only) to trigger EACCES on read, asserts READ_ERROR emitted with correct code/sessionId/cause, verifies watcher is not stopped, restores permissions and verifies watcher recovers and delivers subsequent messages
- "emits WATCH_ERROR and auto-stops when fs.watch errors" — uses `_registry` to access internal FSWatcher, emits a simulated error via `.emit("error", ...)`, asserts WATCH_ERROR emitted with correct code/sessionId/cause, verifies handle is auto-stopped and removed from registry

Files changed:
- src/watcher/watch-session.ts (modified — added error handling for READ_ERROR, PARSE_ERROR, WATCH_ERROR; exported _registry; added blank-line skip)
- src/watcher/__tests__/watch-session.test.ts (modified — added 2 tests, imported chmod, _registry, WatchError)

Gotchas:
- `chmod 0o000` removes all permissions, preventing both read AND write — use `0o200` (write-only) to simulate read errors while still being able to append data to trigger fs.watch events
- `parseLine` documents "Never throws" — the PARSE_ERROR catch is a safety net for truly unexpected failures, not for normal malformed JSON (which returns `MalformedRecord`)
- `Bun.file(path).size` uses `stat()` which doesn't require read permission, so it works even with `chmod 0o200`

Verified: typecheck passes, all 434 tests pass (432 existing + 2 new).

## 2026-02-22 — Phase 2: Blank & Malformed Lines

Implemented:
- Verified blank-line skip behavior: watcher's `line === ""` guard (line 119) prevents blank lines from reaching `parseLine`, so `lineIndex` does not advance and no batch is flushed, while `byteOffset` still advances past the newline bytes
- Verified malformed JSON behavior: `parseLine` returns `MalformedRecord` (not null) for invalid JSON, so it gets pushed to `pendingMessages` and `lineIndex` increments — watcher continues processing subsequent lines normally

Tests added:
- "skips blank lines without advancing lineIndex or flushing a batch" — appends `"\n\n"`, asserts no batch flushed, `byteOffset` advanced to 2, `lineIndex` remains 0
- "delivers MalformedRecord for invalid JSON with correct lineIndex" — appends invalid JSON then a valid line, asserts first message is `MalformedRecord` at lineIndex 0, second is valid `user-prompt` at lineIndex 1, watcher continues normally

Files changed:
- src/watcher/__tests__/watch-session.test.ts (modified — added 2 tests in new "blank & malformed lines" describe block)
- plans/file-watcher.md (modified — checked off 4 items)

Verified: typecheck passes, all 436 tests pass (434 existing + 2 new).

## 2026-02-22 — Phase 3: End-to-End Consistency

Implemented:
- Added integration test using real fixture data (`src/parser/__tests__/fixtures/minimal-session.jsonl`)
- Reads fixture file, computes expected messages via `parseLine` directly, then appends lines one-by-one to a temp file with watcher at offset 0 and `debounceMs: 0` / `maxWaitMs: 0`
- Verifies all batched messages match `parseLine` output exactly: same count, same order, same `lineIndex`, deep equality on full message objects
- Verifies `byteRange` covers the entire file (start=0, end=file size)

Tests added:
- "batched messages match parseLine output exactly for real fixture data" — uses `minimal-session.jsonl` (4 lines: file-history-snapshot, user-prompt, assistant-block, system-turn-duration), asserts watcher delivers identical messages to direct `parseLine` calls

Files changed:
- src/watcher/__tests__/watch-session.test.ts (modified — added 1 test in new "end-to-end consistency" describe block, added `readFile` and `join` imports, added `parseLine` import)
- plans/file-watcher.md (modified — checked off 2 items)

Verified: typecheck passes, all 437 tests pass (436 existing + 1 new).
